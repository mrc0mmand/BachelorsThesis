%=========================================================================
% (c) Michal Bidlo, Bohuslav KÅ™ena, 2008

\chapter{Introduction}
    SSL/TLS is the most widely used technology for securing today's Internet communications.
    Every application, which transmits data over the Internet, should implement
    some kind of encryption and many of these applications use SSL/TLS. But, as
    the correct way of implementing such encryption can be very tricky, and
    a simple mistake may have severe consequences, several general-purpose
    implementations -- libraries -- were created. These libraries allow the
    application to use SSL/TLS without having to create their own implementation.

    Even though these libraries follow certain standards, which should ensure
    their interoperability (ability to communicate with any library which
    implements SSL/TLS according to the standards), they may contain little
    deviations or issues which can cause unexpected behavior or even some more
    serious problems (like denial of service). To avoid,
    or to at least detect, such issues, we can implement tests, which will test the
    interoperability between the SSL/TLS libraries. This is one of the main
    goals of this thesis.

    Executing these tests manually for different environments would be ineffective,
    tedious and not error-prone.
    Thus, using an automation, which would test various combinations of different
    library versions on different versions of operating systems is necessary.
    Such automation -- in this case we call it \textit{continuous integration} -- is
    the second main topic of this thesis.

    By combining all these features together, we get a powerful system for continuous
    SSL/TLS library testing. Such system can be used for regression detection
    and ensuring, that interoperability between two given libraries works in a specific
    environment with a specific combination of settings.

\section{Structure of the Document}
    All necessary components
    for such system are described in the following chapters, starting with a
    brief description of SSL/TLS protocols and their features in
    chapter~\ref{chap:ssl_tls}.

    Chapter~\ref{chap:continuous_integration}
    describes various continuous integration systems, which were considered
    for the final solution, and how the implemented solution looks like.

    The testing itself, along with used technologies, is discussed in
    chapter~\ref{chap:ssl_tls_testing}. This chapter also includes a list
    and description of libraries, which were chosen to be tested and why.

    During the testing phase several issues were found. Some of them are "harmless",
    others can have a serious impact on the application, which uses given library.
    Summary of these results is detailed in chapter~\ref{chap:testing_results}
    following a thesis summary in chapter~\ref{chap:conclusion}.

\chapter{Secure Sockets Layer / Transport Layer Security} \label{chap:ssl_tls}
    \textit{Secure Sockets Layer}~(SSL) and its successor
    \textit{Transport Layer Security}~(TLS) are cryptographic protocols
    designed to provide communications security over a computer network. As
    the latest version of the SSL protocol (version~3.0~\cite{rfc6101}) was
    deprecated in June~2015~\cite{rfc7568} it will not be discussed
    further in this thesis.

    Although there are currently three TLS versions -- TLS 1.0~\cite{rfc2246},
    TLS 1.1~\cite{rfc4346} and TLS 1.2~\cite{rfc5246} -- this thesis focuses
    only on the latest two as TLS 1.0 is basically SSL 3.0 with a few
    differences. Also, there were few cryptographic problems found
    in TLS 1.0 and later resolved in TLS 1.1 (e.g. BEAST~\cite{duong2011}).

\section{Overview}\label{ref:overview}
    The primary goal of the TLS protocol is to provide privacy and data
    integrity between two communicating applications. The structure of
    the protocol comprises two layers: the TLS Record Protocol and
    the TLS Handshake Protocol.

    The TLS Record Protocol lies at the lowest level, above some reliable
    transport protocol (e.g., TCP~\footnote{Transmission Control Protocol}).
    This protocol provides security which has following properties:
    \begin{itemize}
        \item The connection is private. Symmetric cryptography is used
        for data encryption (e.g., AES~\footnote{Advanced Encryption Standard},
        Camellia, 3DES~\footnote{Triple DES (Data Encryption Standard)}, etc.).
        The keys for the symmetric encryption are generated uniquely
        for each connection
        and are based on a secret negotiated by another protocol
        (such as the TLS Handshake Protocol). The TLS Record Protocol can also
        be used without encryption.
        \item The connection is reliable. Message transport includes
        a message integrity check using a keyed
        MAC~\footnote{Message Authentication Code}. Secure hash functions
        (e.g., SHA-1~\footnote{Secure Hash Algorithm}, SHA-256, etc.) are
        used for MAC computations. The MAC is used to prevent undetected
        data loss or data modification during transmission.
    \end{itemize}

    The TLS Record Protocol is used for encapsulation of various higher-level
    protocols. One such protocol is the TLS Handshake Protocol. This protocol
    allows client authentication and negotiation of necessary properties
    of the TLS connection, like encryption algorithm or cryptographic keys,
    before the data transmission. The TLS Handshake Protocol provides
    connection security which has following properties:
    \begin{itemize}
        \item The peer's identity can be authenticated using asymmetric, or
        public key, cryptography (e.g.,
        RSA~\footnote{Rivest-Shamir-Adleman cryptosystem},
        ECDSA~\footnote{Elliptic Curve Digital Signature Algorithm}, etc.).
        This authentication is not mandatory, but it is generally required
        for at least one of the peers.
        \item The negotiation of a shared secret is secure. Obtaining of
        the shared secret is infeasible for any eavesdropper or attacker,
        who can place himself in the middle of the authenticated connection.
        \item The negotiation is reliable. The negotiation communication
        cannot be modified without being detected by the parties to the
        communication.~\cite{rfc5246}
    \end{itemize}

    In addition to the properties above, a carefully configured TLS connection
    can provide another important privacy-related property: forward secrecy.
    This property ensures, that any future disclosure or leakage of encryption
    keys cannot be used to decrypt any TLS communications recorded or
    eavesdropped in the past.

    TLS supports various combinations of algorithms for key exchange, data
    encryption and message integrity authentication, which is an important fact
    for this thesis and can cause severe issues when these combinations
    are configured or implemented improperly. Along with these combinations,
    TLS supports many extensions further extending its capabilities and possibilities,
    which will be described further in this thesis.

\section{TLS Protocols}
    As mentioned above, the TLS protocol consists of four protocols --
    the TLS Record Protocol, the TLS Handshake Protocol, the TLS Changer Cipher
    Spec Protocol, the TLS Alert Protocol and the TLS Application Data Protocol.
    In this section we will overview and discuss these protocols in more detail.

\subsection{TLS Record Protocol}
    In section \ref{ref:overview} we briefly described the main function of the
    TLS Record Protocol, which is encapsulation of protocol data from higher
    layers. This includes fragmentation, optional compression, MAC application,
    encryption and transmission of the data. On the receiving side the data is
    decrypted, verified, decompressed, reassembled and then delivered to the
    higher layers.

    Through the data processing, following TLS data structures are used --
    \texttt{TLSPlaintext}, \texttt{TLSCompressed} and \texttt{TLSCiphertext}.
    At the end a TLS record is formed by appending an TLS record header to
    the \texttt{TLSCiphertext} structure.

\subsection{TLS Handshake Protocol} \label{ref:tls_handshake_protocol}
    The TLS Handshake Protocol is the core protocol of TLS which operates on
    top of the TLS Record Protocol. Its goal is the authentication of communicating
    peers and negotiation of security parameters necessary for establishment or
    resumption of secure sessions.

    \noindent The session establishment consists of following steps:
    \begin{itemize}
        \item Protocol version negotiation
        \item Cipher suite negotiation
        \item Server authentication and (optional) client authentication using
              digital certificates
        \item Exchange of session key information
    \end{itemize}

    \noindent The actual session establishment using the TLS Handshake Protocol
    proceeds as follows (see~Figure~\ref{fig:full_tls_handshake}):
    \begin{enumerate}
        \item The client sends a \texttt{ClientHello} message to the server, that
              includes the TLS version, a list of cipher suites supported by the
              client (in the client's order of preference) and the client's
              random value, which is used in subsequent computations.
        \item The server responds with a \texttt{ServerHello} message, including
              the protocol version, the cipher suite chosen by the server, the session ID,
              and the server's random value.
        \item If the server is to be authenticated, it sends its certificate in
              a \texttt{Certificate} message.
        \item A \texttt{ServerKeyExchange} message may be sent if the client
              needs some additional information for the key exchange.
        \item If the client authentication is required, the server sends a
              \texttt{CertificateRequest}.
        \item Finally, the server sends a \texttt{ServerHelloDone} message, to
              indicate that the hello-message phase of the handshake is complete.
        \item If the server has sent the \texttt{CertificateRequest} message, the
              client must send the \texttt{Certificate} message containing its
              certificate.
        \item The client sends a \texttt{ClientKeyExchange} message. Its content
              depends on the chosen key exchange algorithm.
        \item If the client has sent its certificate to the server, it must also
              send a digitally-signed \texttt{CertificateVerify} message, which
              explicitly verifies possession of the private key belonging to the
              client's certificate.
        \item The client sends a \texttt{ChangeCipherSpec} message to the server,
              using the TLS Change Cipher Spec Protocol (see
              section \ref{ref:change_cipher_spec}) and copies its pending write state
              into the current write state, which makes the negotiated settings active.
        \item The client sends a \texttt{Finished} message to the server under
              the new write state (with the new algorithms, keys, and secrets).
        \item In response, the server sends its own \texttt{ChangeCipherSpec}
              message, copies its pending write state into the current write
              state and send the \texttt{Finished} message under the new cipher
              spec.
    \end{enumerate}

    \begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \tikzstyle{block} = [draw, rectangle, minimum width=5.5em, minimum height=2.2em, node distance=15em]
        \node[block] (Client) {Client};
        \node[block,right=of Client] (Server) {Server};
        \node[below of=Server, node distance=28em] (ServerGround) {};
        \node[below of=Client, node distance=28em] (ClientGround) {};

        \draw (Client) -- (ClientGround);
        \draw (Server) -- (ServerGround);

        \draw[->] ($(Client)!0.15!(ClientGround)$) -- node[above]{\texttt{ClientHello}} ($(Server)!0.15!(ServerGround)$);

        \draw[<-] ($(Client)!0.25!(ClientGround)$) -- node[above]{\texttt{ServerHello}} ($(Server)!0.25!(ServerGround)$);
        \draw[<-] ($(Client)!0.30!(ClientGround)$) -- node[above]{\texttt{Certificate*}} ($(Server)!0.30!(ServerGround)$);
        \draw[<-] ($(Client)!0.35!(ClientGround)$) -- node[above]{\texttt{ServerKeyExchange*}} ($(Server)!0.35!(ServerGround)$);
        \draw[<-] ($(Client)!0.40!(ClientGround)$) -- node[above]{\texttt{CertificateRequest*}} ($(Server)!0.40!(ServerGround)$);
        \draw[<-] ($(Client)!0.45!(ClientGround)$) -- node[above]{\texttt{ServerHelloDone}} ($(Server)!0.45!(ServerGround)$);

        \draw[->] ($(Client)!0.55!(ClientGround)$) -- node[above]{\texttt{Certificate*}} ($(Server)!0.55!(ServerGround)$);
        \draw[->] ($(Client)!0.60!(ClientGround)$) -- node[above]{\texttt{ClientKeyExchange}} ($(Server)!0.60!(ServerGround)$);
        \draw[->] ($(Client)!0.65!(ClientGround)$) -- node[above]{\texttt{CertificateVerify*}} ($(Server)!0.65!(ServerGround)$);
        \draw[->] ($(Client)!0.70!(ClientGround)$) -- node[above]{\texttt{[ChangeCipherSpec]}} ($(Server)!0.70!(ServerGround)$);
        \draw[->] ($(Client)!0.75!(ClientGround)$) -- node[above]{\texttt{Finished}} ($(Server)!0.75!(ServerGround)$);

        \draw[<-] ($(Client)!0.85!(ClientGround)$) -- node[above]{\texttt{[ChangeCipherSpec]}} ($(Server)!0.85!(ServerGround)$);
        \draw[<-] ($(Client)!0.90!(ClientGround)$) -- node[above]{\texttt{Finished}} ($(Server)!0.90!(ServerGround)$);

        \draw[<->, thick] ($(Client)!0.98!(ClientGround)$) -- node[above]{\texttt{Application Data}} ($(Server)!0.98!(ServerGround)$);
    \end{tikzpicture}
    \caption{Full TLS handshake} \label{fig:full_tls_handshake}
    \end{figure}

    Note: * marks messages which are sent only under specific conditions. \\

    At this point, the TLS handshake is complete, and the peers may begin to
    exchange application layer data.

    \label{ref:session-resumption}
    When the client and the server decide to resume a previous session or duplicate
    an existing one, the handshake can be simplified considerably
    (see Figure~\ref{fig:simplied_tls_handshake}). The client
    sends a \texttt{ClientHello} message including the ID of the session to be
    resumed. The server then checks its session cache for a match. If a match
    is found, and the server is willing to re-establish the connection under
    the specified session state, it sends a \texttt{ServerHello} message with
    the same Session ID value. The client and the server can then directly move
    to the \texttt{ChangeCipherSpec} message followed by the \texttt{Finished}
    message. If a Session ID match is not found in the session cache, the
    server generates a new session ID and the peers perform a full TLS handshake.

    \begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \tikzstyle{block} = [draw, rectangle, minimum width=5.5em, minimum height=2.2em, node distance=15em]
        \node[block] (Client) {Client};
        \node[block,right=of Client] (Server) {Server};
        \node[below of=Server, node distance=14em] (ServerGround) {};
        \node[below of=Client, node distance=14em] (ClientGround) {};

        \draw (Client) -- (ClientGround);
        \draw (Server) -- (ServerGround);

        \draw[->] ($(Client)!0.20!(ClientGround)$) -- node[above]{\texttt{ClientHello}} ($(Server)!0.20!(ServerGround)$);

        \draw[<-] ($(Client)!0.35!(ClientGround)$) -- node[above]{\texttt{ServerHello}} ($(Server)!0.35!(ServerGround)$);
        \draw[<-] ($(Client)!0.45!(ClientGround)$) -- node[above]{\texttt{[ChangeCipherSpec]}} ($(Server)!0.45!(ServerGround)$);
        \draw[<-] ($(Client)!0.55!(ClientGround)$) -- node[above]{\texttt{Finished}} ($(Server)!0.55!(ServerGround)$);

        \draw[->] ($(Client)!0.70!(ClientGround)$) -- node[above]{\texttt{[ChangeCipherSpec]}} ($(Server)!0.70!(ServerGround)$);
        \draw[->] ($(Client)!0.80!(ClientGround)$) -- node[above]{\texttt{Finished}} ($(Server)!0.80!(ServerGround)$);

        \draw[<->, thick] ($(Client)!0.98!(ClientGround)$) -- node[above]{\texttt{Application Data}} ($(Server)!0.98!(ServerGround)$);
    \end{tikzpicture}
    \caption{Simplified TLS handshake} \label{fig:simplied_tls_handshake}
    \end{figure}

    Let's have a closer look at the various messages that are exchanged during
    the TLS handshake:

\subsubsection{\texttt{HelloRequest}} \label{ref:session-renegotiation}
    This message may be sent by the server at any time and tells the client
    to begin a new session negotiation. Client should respond to this
    message with a \texttt{ClientHello}. This message is not often used, but
    it can be useful in some cases, e.g. forcing a session renegotiation for
    a TLS sessions which are active for a longer period of time.

\subsubsection{\texttt{ClientHello}} \label{ref:client_hello}
    The \texttt{ClientHello} message is usually the first message in the TLS
    handshake, sent by the client, which initiates the session negotiation.
    The message itself contains the latest TLS version supported by the client,
    the client's random value, a session ID (which can be empty, if the client
    wishes to negotiate a new session), a list of supported cipher suites,
    a list of compression methods and optional extensions.

\subsubsection{\texttt{ServerHello}}
    The \texttt{ServerHello} is the server's response to the client's
    \texttt{ClientHello} message. The structure of this message is quite similar
    to the \texttt{ClientHello} -- instead of the lists of cipher suites and
    compression methods, the server specifies a single cipher suite and a single
    compression method. These values are chosen from the client's \texttt{ClientHello}
    message and will be used for the session. The complete message contains
    the TLS version chosen by the server, the server's random value, the length
    of the session ID and the session ID, the cipher suite, the compression
    method and the optional extensions.

\subsubsection{\texttt{Certificate}}
    If the agreed-upon key exchange method uses certificates for authentication,
    the server sends a \texttt{Certificate} message containing a
    certificate chain. This certificate chain can be then used by the client,
    to verify the server's identity. The same message is used when a client
    authentication is required (as a response to a \texttt{CertificateRequest}
    message, see below). All exchanged certificates are of X.509 v3
    type~\cite{rfc5280}, if not stated otherwise during the negotiation.

\subsubsection{\texttt{ServerKeyExchange}}
    In some cases, the \texttt{Certificate} message does not contain enough data to
    allow the client to exchange a pre-master secret. In this situation, the
    server sends a \texttt{ServerKeyExchange} message with necessary cryptographic
    information, which allows such exchange and allows the client to complete
    the key exchange.

    When RSA (or Diffie-Hellman with fixed parameters) is used, the client can retrieve
    the public key (or the server's Diffie-Hellman parameters) from the server certificate.
    In these cases the \texttt{Certificate} message is enough to complete
    a key exchange. But, for example, in case of ephemeral Diffie-Hellman, the client
    needs some additional information --- Diffie-Hellman parameters --- which
    must be delivered in a \texttt{ServerKeyExchange} message.

\subsubsection{\texttt{CertificateRequest}}
    When the server wants to authenticate the client, it sends
    a \texttt{CertificateRequest} message to the client. This message tells
    the client which certificates are accepted by the server, and also asks
    the client to send its certificate to the server. Only a non-anonymous
    server can send a \texttt{CertificateRequest} -- that means a server, which
    authenticates itself using the \texttt{Certificate} message.

\subsubsection{\texttt{ServerHelloDone}}
    This message is sent by the server and indicates the end of the section
    of messages initiated by the \texttt{ServerHello} message. After sending
    this message, the server will wait for a client response.

\subsubsection{\texttt{ClientKeyExchange}}
    The \texttt{ClientKeyExchange} message is sent by the client and it provides
    the server with the client-side keying material, which is used to generate
    the pre-master secret.

\subsubsection{\texttt{CertificateVerify}}
    If the client provided a certificate that has a signing capability, it
    must prove that it holds the corresponding private key for that certificate.
    In this case, the client sends a digitally signed \texttt{CertificateVerify}
    message to the server. This allows the server to verify the client certificate
    using the client's public key and authenticate the client.

\subsubsection{\texttt{Finished}}
    The \texttt{Finished} message is always sent immediately after a
    \texttt{ChangeCipherSpec} message~\ref{ref:change_cipher_spec} to verify
    that the key exchange and authentication processes were successful.
    As the message follows the \texttt{ChangeCipherSpec} message, it is the
    first message protected by the newly negotiated algorithms and keys.

\subsection{TLS Change Cipher Spec Protocol} \label{ref:change_cipher_spec}
    The TLS Change Cipher Spec Protocol is used to signal transitions in
    ciphering strategies. The protocol itself consists of a single compressed
    and encrypted message -- \texttt{ChangeCipherSpec}. The encryption and
    compression methods correspond to the current (not the pending) cipher
    spec.

    After receiving this message, the receiver instructs its record layer
    to immediately copy the read pending state into the read current state.
    Similarly, immediately after sending this message, the sender instructs
    its record layer to copy the write pending state into the write current
    state. All subsequent messages sent by the sender are then protected under
    the newly negotiated cipher spec.

\subsection{TLS Alert Protocol}
    To exchange alert messages between peers, like warnings and errors, the
    TLS Alert Protocol is used. Each alert message has its severity (warning,
    fatal) and a description of the alert. All messages with an alert level
    of fatal result in the immediate termination of the connection.

    The alert's description field contains an identificator of the alert.
    These descriptions can be split into two categories -- closure alerts
    and error alerts. The former one contains only one alert --
    \texttt{close\_notify}. This message can be send by either party and
    notifies the recipient that the
    sender will not send any more messages. Any data received after this message
    must be ignored. The knowledge of the fact, that the connection is ending,
    is crucial to avoid truncation attacks.
    The second category contains a number of error alerts used for various
    purposed during the TLS session. All TLS alert messages are summarized
    in Table~\ref{tab:tls-alerts}.

\subsection{TLS Application Data Protocol}
    The TLS Application Data Protocol takes the arbitrary data from the application
    layer and feeds it into the TLS Record Protocol for fragmentation, compression
    and encryption. The resulting TLS records are then sent to the recipient.

\section{Cipher Spec and Cipher Suite}
    In previous sections, terms \textit{cipher spec} and
    \textit{cipher suite} were mentioned. Let's have a closer look at their meanings.

    A \textit{cipher spec} refers to a pair of algorithms that are used
    to cryptographically protect data. Such pair consists of a message
    authentication algorithm (\textit{MAC}) and a data encryption algorithm. If we
    add a key exchange algorithm to a cipher spec, we get a \textit{cipher suite}.

    For example, \textit{TLS\_DHE\_RSA\_AES\_256\_CBC\_SHA1} refers to a TLS
    cipher suite which uses ephemeral Diffie-Hellman with RSA for a key
    exchange, 256-bit AES in CBC~\footnote{Cipher Block Chaining} mode for
    encryption, and SHA-1 for message authentication.

\section{TLS Extensions}
    As mentioned in section~\ref{ref:tls_handshake_protocol}, the \texttt{ClientHello}
    and \texttt{ServerHello} messages contain an optional field for extensions.
    These extensions can be used to add functionality to TLS.

    When a client wants to use an extension
    it sends its name in the \texttt{ClientHello} message. If the
    extension is supported by the server, it will be included in the responding
    \texttt{ServerHello} message. However, if the \texttt{ServerHello} message
    contains an extension, which was not sent by the client, the connection
    must be aborted with an \texttt{unsupported\_extension} fatal
    alert~(\ref{tab:tls-alerts}).~\cite{rfc3546}~\cite{rfc4366}

    Describing all currently implemented extensions~\cite{rfc6066} is
    way beyond scope of this thesis.
    Thus, in the following paragraphs we will discuss only those extensions,
    which are currently tested by the implementation part of this thesis.
    Nevertheless, support for other extensions is highly probable in
    the near future.

\subsection{Session Tickets} \label{ref:sessionticket-ext}
    If a client wanted to resume an existing session, it would have to
    send a session ID in its \texttt{ClientHello} message (field \texttt{session\_id})
    and the server would have to check its cache for a match (see
    section~\ref{ref:tls_handshake_protocol}). This may cause problems on systems
    with a large amount of requests from different users or on systems with
    little memory. For such cases there is a \texttt{SessionTicket} TLS extension which uses
    client-side caching.~\cite{rfc5077}

    In the initial handshake, where the client does not possess a ticket for an existing
    session, it includes an empty \texttt{SessionTicket} TLS extension in
    its \texttt{ClientHello} message. The server responds with an empty
    \texttt{SessionTicket} extension to indicate that it will send a new session
    ticket using the \texttt{NewSessionTicket} message. This ticket contains
    the current session state (such as cipher suite and master secret) and is
    cryptographically protected by a key, which is known only to the server.

    When the client wishes to resume the session, it includes the cached ticket
    in the \texttt{SessionTicket} extension of its \texttt{ClientHello} message.
    The server then decrypts and verifies the contents of the ticket and resumes
    the session according to the decrypted parameters. If the server cannot,
    or does not want to use the state from the ticket, it can initiate
    a full handshake with the client.

\subsection{Signature Algorithms} \label{ref:signature-algorithms}
    TLS 1.2 defines (\cite{rfc5246}, section 7.4.1.4.1) an extension
    \texttt{supported\_signature\_algorithms}, which allows the client to tell
    the server which hash and signature algorithm combinations it supports.
    Even though internally the supported algorithms are split into two lists
    (none, MD5, SHA-1, SHA-224, SHA-256, SHA-384 and SHA-512 for hash algorithms
    and anonymous, RSA, DSA and ECSDA for signature algorithms), the algorithms
    sent in the extension are always listed in pairs, as not all combinations
    may be accepted by an implementation.

    The peers exchange this information through the \texttt{ClientHello} and
    \texttt{ServerHello} messages including the \texttt{supported\_signature\_algorithms}
    extension. The client sends a list of supported algorithms and the server
    responds with its choice, that is going to be used for any subsequent signature
    generation and verification.

\section{Libraries}
    To prevent each project implementing the SSL/TLS on its own and introducing
    (in many situations) dangerous issues, several libraries were created and
    can be used by any project, which needs a SSL/TLS support. The most
    popular ones are OpenSSL~\footnote{https://www.openssl.org/},
    NSS~\footnote{https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS}
    and GnuTLS~\footnote{https://www.gnutls.org/}. Although, there are other
    SSL/TLS libraries (e.g. LibreSSL~\footnote{https://www.libressl.org/} or
    BoringSSL~\footnote{https://boringssl.googlesource.com/boringssl/}),
    this thesis aims only on these three. However, a future
    expansion to support other libraries is not impossible.

    Even though these libraries are
    separate projects, an user of such library must be able to communicate with every client,
    which supports the particular protocol and cipher suite, no matter which
    implementation they use. Testing of this functionality --- \textit{interoperability} ---
    is the main goal of this thesis.

    For the testing itself we need at least two applications - a client and a server.
    One option would be writing these applications from scratch, using the public
    API~\footnote{Application Programming Interface} of each library,
    which is not error prone and would require a maintenance of such applications.
    Thankfully, each of the tested libraries provides a set of utilities,
    among which we can find a simple client and server applications with
    dozens of settings and options. These utilities are then used in
    various scenarios to ensure, that given valid combination of settings works
    for both client and server using different libraries.

\subsection{OpenSSL}
    OpenSSL is an open source library maintained by The OpenSSL Project,
    which provides a toolkit for SSL and TLS
    protocols, along with other general-purpose cryptographic functions.

    This library provides a single powerful utility called \textit{openssl}. This
    utility has dozens of sub-commands with various SSL/TLS related functionality,
    where the most important ones are:
    \begin{description}
        \item [ciphers] information about supported cipher suites
        \item [dsa, rsa, ec] DSA/RSA/EC key management
        \item [s\_client] a simple SSL/TLS client
        \item [s\_server] a simple SSL/TLS server
        \item [x509] X.509 certificate data management
    \end{description}

    Thanks to its functionality-rich interface, OpenSSL is used for certificate
    generation and management for all libraries in the testing process.

\subsection{NSS}
    Network Security Services~(NSS) is a set of open source libraries providing
    support for SSL and TLS protocols,
    S/MIME~\footnote{Secure/Multipurpose Internet Mail Extensions}
    and other optional features, like
    server-side TLS/SSL acceleration or client-side hardware smart cards support.

    Compared to OpenSSL, which has a single utility for everything, NSS does
    the exact opposite -- each feature or tool has its own utility. For our
    testing purposes, we will need the following ones:
    \begin{description}
        \item [certutil] certificate and key management for NSS databases
        \item [listsuites] information about supported cipher suites
        \item [selfserv] a simple SSL/TLS server
        \item [strsclnt] a simple SSL/TLS client for performance testing
        \item [tstclnt] a simple SSL/TLS client
    \end{description}

    This library differs from the other two in the way how it handles
    server and client certificates. These certificates cannot be passed
    directly as arguments to the utility, but must be imported to a NSS
    database which is then passed as an argument to the utility.

\subsection{GnuTLS}
    GnuTLS is a secure communications library which implements SSL, TLS and
    DTLS~\footnote{Datagram Transport Layer Security} protocols.

    Like the the libraries above, GnuTLS includes several utilities for library
    testing - GnuTLS client \textit{gnutls-cli} and GnuTLS server
    \textit{gnutls-serv}. Both utilities support a parameter \textbf{-l},
    which lists all necessary information about supported cipher suites.


\chapter{Implementation Details}
    Following sections describe in detail the most important part of this thesis
    -- implementation of the continuous integration system, test extension,
    and how these two parts work together to ensure interoperability of
    SSL/TLS libraries.

    As the majority of the tests for this thesis were not developed from scratch,
    section~\ref{ref:test-extension-details}
    contains a comprehensive review of things which were added
    throughout the implementation of this thesis.

\section{Tested Environments}
    For the purposes of this thesis, an environment consists of an operating
    system (e.g.
    CentOS~\footnote{https://www.centos.org/},
    Fedora~\footnote{https://getfedora.org/}) and its version
    (e.g. 7, 25). Each of these environments must be tested separately, as
    it contains a different set of library versions and policies, which
    affect the SSL/TLS communication.

    This thesis covers SSL/TLS libraries on CentOS and Fedora, as the tests used
    and extended by this thesis were originaly created for
    RHEL~\footnote{Red Hat Enterprise Linux -
    https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux}.

\section{Test Format}
    Each test consists of two main files -- \textit{runtest.sh} and \textit{Makefile}
    -- and other optional auxiliary files. Makefile contains metadata of the
    particular test, such as its name, author, version, dependencies, information
    about relevancy, package it tests, etc. It also contains several make
    targets, so for example \texttt{make run} makes the runtest.sh executable
    and runs it. The CI makes use of this file and extracts some necessary
    information from it -- namely dependencies and relevancy -- to ensure
    correct execution of the test itself.

    The second file -- runtest.sh -- is the core of the test. It is a Bash
    script using the BeakerLib~\footnote{https://github.com/beakerlib/beakerlib}
    testing framework containing a sequence of commands and asserts which
    are executed and evaluated. Each command execution or an assert
    creates a record in a log, which is processed, stored and printed at the end of
    each test run.

    Let's have an example runtest.sh script, which simply generates an elliptic
    curve key and checks if it contains "BEGIN EC PRIVATE KEY"
    (Figure~\ref{fig:runtest.sh}). When executed, BeakerLib generates two
    logs -- the first one is generated throughout the test execution and contains
    outputs of all executed commands, whether the second one is generated at
    the end of the test and contains a summary of the first log. An execution
    log can be seen in Figure~\ref{fig:runtest.sh-log}.

    \begin{figure}
        \begin{lstlisting}[language=Bash,basicstyle=\small]
. /usr/share/beakerlib/beakerlib.sh || exit 1

PACKAGE="openssl"

rlJournalStart
    rlPhaseStartSetup
        rlAssertRpm $PACKAGE
        rlRun "TestDir=\$(pwd)"
        rlRun "TmpDir=\$(mktemp -d)" 0 "Creating tmp directory"
        rlRun "pushd $TmpDir"
    rlPhaseEnd

    rlPhaseStartTest
        rlRun "openssl ecparam -genkey -name prime256v1 -out ec.key"
        rlAssertGrep "BEGIN EC PRIVATE KEY" "ec.key"
    rlPhaseEnd

    rlPhaseStartCleanup
        rlRun "popd"
        rlRun "rm -r $TmpDir" 0 "Removing tmp directory"
    rlPhaseEnd
rlJournalPrintText
rlJournalEnd
        \end{lstlisting}
        \caption{Example runtest.sh file} \label{fig:runtest.sh}
    \end{figure}

    \begin{figure}
        \begin{lstlisting}[basicstyle=\small]
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: [   LOG    ] :: Setup
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

openssl-1.1.0c-5.fc26.x86_64
:: [   PASS   ] :: Checking for the presence of openssl rpm
:: [ 22:32:45 ] :: Package versions:
:: [ 22:32:45 ] ::   openssl-1.1.0c-5.fc26.x86_64
:: [  BEGIN   ] :: Running 'TestDir=$(pwd)'
:: [   PASS   ] :: Command 'TestDir=$(pwd)' (Expected 0, got 0)
:: [  BEGIN   ] :: Creating tmp directory :: actually running
                   'TmpDir=$(mktemp -d)'
:: [   PASS   ] :: Creating tmp directory (Expected 0, got 0)
:: [  BEGIN   ] :: Running 'pushd /tmp/tmp.qHTxIVtyY2'
/tmp/tmp.qHTxIVtyY2 /tmp
:: [   PASS   ] :: Command 'pushd /tmp/tmp.qHTxIVtyY2'
                   (Expected 0, got 0)

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: [   LOG    ] :: Test
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:: [  BEGIN   ] :: Generate an EC key :: actually running
                   'openssl ecparam -genkey -name prime256v1
                   -out ec.key'
:: [   PASS   ] :: Generate an EC key (Expected 0, got 0)
:: [   PASS   ] :: File 'ec.key' should contain 'BEGIN EC PRIVATE KEY'

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: [   LOG    ] :: Cleanup
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:: [  BEGIN   ] :: Running 'popd'
/tmp
:: [   PASS   ] :: Command 'popd' (Expected 0, got 0)
:: [  BEGIN   ] :: Removing tmp directory :: actually running
                   'rm -r /tmp/tmp.qHTxIVtyY2'
:: [   PASS   ] :: Removing tmp directory (Expected 0, got 0)
        \end{lstlisting}
        \caption{Execution log of the runtest.sh from Figure~\ref{fig:runtest.sh}}
        \label{fig:runtest.sh-log}
    \end{figure}

\subsection{Test relevancy} \label{ref:test-relevancy}
    To control in which environments should be each test case executed, we have
    to implement an algorithm, which would check if a given test case is relevant
    for a given environment before the execution itself. The information about
    relevant environments is stated in the Makefile of each test case and has
    a following format:

    \begin{lstlisting}
"Releases:        -RHEL4 -RHELClient5 -RHELServer5"
    \end{lstlisting}

    The test will be excluded from all environments, which have a - symbol
    before their name. Environments not included in the list are implicitly
    added when the final check is done. The same syntax can be used for
    architectures as well, but as the current CI is limited to an x86\_64
    architecture, it is not relevant for this thesis.

    To apply this relevancy during the testing itself a simple script was
    created, which parses the Makefile and compares the parsed environments
    with the current one. If a match with a non-excluded environment is found,
    the test is executed, otherwise it is simply skipped.

    As the CentOS and RHEL environments are basically the same, the relevancy
    script is able to interchange between these two environments to avoid
    unnecessary duplicites in the Makefile. Thus, a \texttt{RHEL7} environment
    from the Makefile matches both CentOS 7 and RHEL 7 environments.

\section{Tested Features}
    Each library goes through several layers of testing:

    \begin{itemize}
        \item \textbf{Basic interoperability} -- Simple communication without
            any special settings
        \item \textbf{Session resumption} -- Verify if session resumption works
            (Section~\ref{ref:session-resumption}); this test is done twice --
            with Session IDs and with SessionTicket
            extension (Section~\ref{ref:sessionticket-ext})
        \item \textbf{Session renegotiation} -- Verify if session renegotiation
            works (Section~\ref{ref:session-renegotiation})
        \item \textbf{signature\_algorithms}* -- Verify if signature\_algorithms
            extension works (Section~\ref{ref:signature-algorithms})
    \end{itemize}

    * This test is (so far) not implemented for all supported libraries, as
    some of them lack necessary support on CentOS. \\

    All mentioned tests are performed multiple times -- with and without
    client certificates, with and without TLSv1.2 enabled, and for each
    supported ciphersuite.

    Apart from these tests, each tested combination has a \textit{Common Criteria}
    test~\footnote{https://www.commoncriteriaportal.org/} which test
    the necessary subset of functionality which is required to work according
    to the library specifications and standards.

\section{Continuous Integration System}
    As manual testing is often tedious and not error prone, an automated system
    has to be implemented to test a developed component both periodically and
    on-demand, when developer requests it. Such system should be capable of
    running all relevant tests on given component without (almost) any manual
    intervention and reporting results back to the person, who requested
    it.~\cite{amazon-ci}

    During the progress of thise thesis, we tried several solutions before
    implementing and accepting the final one.

\subsection{GitHub \& Webhooks}
    First of the proposed solutions was a simple Python script, which would
    make use of GitHub's webhooks~\cite{github-webhooks}. This script would listen
    for requests from GitHub and would perform required tasks.

    This solution, even though it was very flexible, would require re-implementation
    of many things already implemented in already existing solutions, which would
    consume unnecessary amount of time, that could be utilized for other, more important things.

\subsection{Jenkins}
    During the search for more robust and complete solution, we come across
    Jenkins. Jenkins is an open-source automation server, which can be used
    for automation of various tasks~\cite{jenkins-docs}. After several
    proof-of-concept solutions we knew that Jenkins is something we can
    build on.

    Nevertheless, Jenkins itself lacks integration with GitHub. Thankfully, that
    could be solved by using several open-source plugins. First of them is
    \textit{GitHub Plugin}~\footnote{https://wiki.jenkins-ci.org/display/JENKINS/GitHub+Plugin},
    which provides basic integration with GitHub and functionality for other
    GitHub plugins. This functionality is used and improved by
    \textit{GitHub pull request builder plugin}~\footnote{https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin},
    which adds support for polling from GitHub webhooks, trigger hooks for
    specific comments in pull requests, customizable build status messages and
    others.

    Combining all these things above together, we were able to create a working
    automation system -- \textit{CI} -- which reacted to changes in the test
    repository and reported build results back to it. The major disadvantage
    was in running all build tasks on the same machine as the Jenkins itself.
    So the another necessary task was implementing some kind of isolation
    for the build tasks.

    In our current infrastructure we use Beaker~(Section~\ref{ref:beaker}) for machine
    provision, where each tasks (or a set of tasks) has its own machine. This sounded like exactly
    what we needed, but that would require obtaining machines for a machine pool
    and their maintenance, which was far too excessive for a such small project.

    Taking inspiration from another of our internal projects, we thought about
    using OpenStack~(Section~\ref{ref:openstack}) for provision of virtual
    machines. OpenStack could run on the same machine as Jenkins, so we would not
    need another hardware. Also, the provision can be done from pre-installed
    images, so it would be much faster than in case of Beaker. Unfortunately,
    after spending several hours by reading documentation and playing around with
    OpenStack itself, we have concluded, that it would be too demanding
    to maintain.

    Finally, we managed to isolate build tasks using Docker containers~(Section~\ref{ref:docker}).
    But, after this step, where we managed to get rid of dependency on other machines,
    and basically on dependency on the underlying operating system itself, we
    were trying to move everything somewhere to the cloud, so we would be free
    of the need of maintaining our own infrastructure. And thankfully, after
    another trial and error, we managed to accomplish that goal using Travis.

\subsubsection{Beaker} \label{ref:beaker}
    Beaker is an open-source software for managing and automating labs of test
    computers.~\cite{beaker-docs} It allows administrators and users to maintain an
    automated invetory of all machines present in the machine pool with
    system details, running tasks on machines with specific environments and
    reporting (and storing) results back.

\subsubsection{OpenStack} \label{ref:openstack}
    OpenStack is an open-source cloud operating system for managing pools of compute, storage,
    and networking resources.~\cite{openstack-docs} For easier administration and
    usage, almost everything can be managed through a web dashboard, which provides
    all necessary information. OpenStack itself consists of several components,
    which can be added or removed according to the particular needs.

\subsubsection{Docker} \label{ref:docker}
    Docker is an open-source project which automates deployment of applications
    inside containers.~\cite{docker-docs} Container is a small, executable image,
    which contains all necessary software to run a desired application without
    any other external dependencies, in an isolated environment. This approach
    allows an user to run an application under a different operating system -- e.g.
    running an application in a CentOS 7 container even though the host operating
    system is Ubuntu. This feature is crucial in the CI implemented in this thesis.

\section{Final CI Implementation with Travis CI}
    As mentioned above, the chosen solution is Travis CI. Travis CI is a powerful,
    hosted, distributed continuous integration service, used exclusively to
    build and test projects hosted at GitHub.~\cite{travis-ci-docs} It has two
    variants -- commercial, for private projects and free, for open-source
    projects. As all tests and scripts from this thesis are open-source, and
    we were already using GitHub, wecould use the free variant and throw away
    the need for our own infrastructure.

    After hooking a repository to Travis, it reacts to all commits, branches
    and pull requests, for which a new build is created. Status of each build
    is reported back to GitHub in two ways -- for commits it is an icon
    in their summary (yellow dot for a running build, green tick for a passed
    build and red cross for a failed build), and for pull requests it is located
    in the information box of each pull request. Both ways contain
    a hyperlink to the particular
    build with genreal overview and status with logs for each job (environment).

    Nevertheless, even though Travis CI met our expectations, it was not exactly
    "out-of-the-box" solution, as several obstacles had to be overcome.

\subsection{Operating System}
    First major issue was the OS used by Travis CI, which is Ubuntu, as our
    tests should run on CentOS and Fedora. Thankfully, using and extending the
    already implemented solution from the previous experience with
    Jenkins, we were able to workaround this issue using Docker containers.
    Both CentOS~\footnote{https://hub.docker.com/\_/centos/} and
    Fedora~\footnote{https://hub.docker.com/\_/fedora/} have official images
    for Docker, so we did not have to bother with making and maintaining our
    own Docker images.

    Travis CI itself supports Docker, so we can simply tell Travis to enable
    Docker for our build, pull a correct docker image and then simply run
    whatever we want inside the container.

\subsection{Test Environments}
    Even though Travis does know the concept of environments, and has a built-in
    mechanism for specifying a matrix of environment variables, where each
    set specifying an environments has its own job, it still needs some handler,
    which would correctly set up the environment according to these settings.

    For this purpose, a short Bash script was written~\footnote{\texttt{scripts/test-setup.sh}}.
    This script takes four arguments -- OS type
    (centos, fedora), OS version (7, 25, \dots), tested component (openssl, gnutls,
    nss) and glob pattern for further test case specificiation
    (see Section~\ref{ref:performance-limits}).

    Before executing the tests itself, several preparation steps need to be made
    to install and configure all necessary dependencies. First of them is
    library certgen~\footnote{https://github.com/redhat-qe-security/certgen},
    written by Hubert Kario, for generating certificates, which are later used
    in the testing process.

    The second dependency, or to call it properly -- the second workaround, is
    creating a fake library for
    FIPS~\footnote{Federal Information Processing Standard - http://csrc.nist.gov/groups/STM/cmvp/standards.html}
    configuration, as FIPS is not supported
    by Travis (yet). When this library is loaded properly, it configures
    system into a FIPS mode. Current solution just returns zero (success) without
    any changes to the underlying system, which allows us running tests even in
    Travis without FIPS support.

    The last thing before the Docker execution itself is checking each test
    for \texttt{rlGetTestState} command. This command must be present as
    the last thing in each test, as all BeakerLib tests return zero even
    if they contain failed phases. Ensuring, that each test has this command
    at its end, gives us relevant results from each test, as
    \texttt{rlGetTestState} returns a number of failed phases as the script's
    exit code (or 255 if the number of failed phases is bigger
    than 255).~\cite{beakerlib-gh-man}

    After the preparations, a docker container is executed with given environment
    settings and the \texttt{scripts/test-runner.sh} script as an entry point.
    This script will be described in detail in the following section.

\subsection{Test Execution} \label{ref:test-execution}
    As the test suite contains several tests, where each one of them lies in
    its own script file, it does not have any entry point, which could be passed
    to Docker to run all tests. For this case,
    a~script~\footnote{scripts/test-runner.sh} had to be created,
    which would coordinate test execution according to the current environment.

    This script has the same arguments as the \texttt{test-setup.sh} -- OS type,
    OS version, component and test glob -- which are used to determine
    a~package manager (yum on CentOS or dnf on Fedora), correct OS version
    (Docker images support a "latest" tag, which needs to be translated to
    an exact version), and whether to configure
    EPEL~\footnote{https://fedoraproject.org/wiki/EPEL} repository, as BeakerLib
    is not in base repositories on CentOS.

    As these test were originally developed for RHEL (and still are),
    another workaround had to be implemented to avoid complex branching in
    the tests. BeakerLib
    has a function \texttt{rlIsRHEL}, which allows certain phases to be
    run only on some version of RHEL -- e.g. condition
    \texttt{if rlIsRHEL 6; then ...} would execute a code inside of the if
    statement only on RHEL 6. But this function does not work on CentOS. For
    CentOS, there is a conveniently named function \texttt{rlIsCentOS}, which
    does the same thing. To avoid having to use both functions for each
    if statement, the \texttt{test-runner.sh} creates a wrapper function
    \texttt{rlIsRHEL} which overloads the original function. The overloaded
    function then simply calls \texttt{rlIsCentOS}, so the tests can use
    the RHEL function only.

    Next step is a full system upgrade, as the Docker images are usually not
    up to date, followed by installation of basic dependencies necessary
    for the test execution.

    The core of the test runner scripts consist of a loop, which goes through
    all tests for given component. If the test passes through all relevancy
    checks, it is executed, otherwise it is skipped.

    The first relevancy check is via the previously mentioned glob pattern,
    which uses extended globbing feature of Bash. This glob pattern is then
    simply matched with the test case name -- if it matches, the test continues
    to the next relevancy check, otherwise it is skipped.

    The second check is a comparison of OS version and OS type with metadata
    from the test's Makefile (see Section~\ref{ref:test-relevancy}). For this
    purpose we have a script \texttt{scripts/relevancy.awk} written, as the
    name suggests, in GNU~AWK~\footnote{https://www.gnu.org/software/gawk/}.
    This script, apart from the comparison itself, performs necessary
    substitutions between RHEL and CentOS to give correct results.

    If a test passes through all relevancy checks, its Makefile is parsed once
    again for dependencies (section \textit{Requires}). These dependencies
    are installed and the test is executed.

    The test runner keeps statistics of executed, skipped and failed tests,
    which are logged along the test results and can be viewed in the Travis
    web UI.

\subsection{Performance and Limits} \label{ref:performance-limits}
    During the CI development, we found out about several limiting factors
    in Travis, which had to be solved. Some of them are related only to
    the free version of Travis CI (for open-source projects), and some
    of them affecting all Travis versions.

    First one is a time limit per job, which is 50 minutes. At the beginning
    of this thesis this was not an issue, as there was a quite big reserve in
    this matter. Nevertheless, as more and more test combinations were added,
    this limit was hit several times.

    Originally, each OS type and version has its own job, so there was one job
    for CentOS 6, one for CentOS 7 and one for the latest Fedora. The first
    step of solving the aforementioned issue
    was creating a separate job for each OS type, version and component
    combination. This resulted in nine jobs (GnuTLS, NSS and OpenSSL times
    supported operating systems) which were enough, at least for a while.

    As another batch of changes was added, the limit was hit again on Fedora
    along with another, previously unknown limit -- the size of the result log
    -- which is 4 MiB.
    After several proposed solutions we decided to add another variable
    to the environment definition -- test glob -- which allows splitting
    each component test suite internally into smaller pieces, depending on their
    name. This solution proved to be quite effective and should last for
    a while (until we reach another milestone, where one test runs for more than
    50 minutes).

\subsection{On-demand Library Compilation}
    To be able to call this system a "continuous integration system", there had
    to be a way how to test a development version of a SSL/TLS library. This
    appeared to be a complicated issue, as Travis itself does not support
    monitoring of external repositories, thus it is not able to tell whether
    a new change was commited to such
    repository.~\footnote{https://github.com/travis-ci/travis-ci/issues/631}

    As stated in previous sections, any dependency on an external infrastructure
    is an unwanted solution (e.g. an external watchdog). Thus, after several proposals,
    a semi-automated solution was implemented, which consists of a small configuration
    file, containing a path to a repository with target SSL/TLS library,
    a branch, which contains desired library version, and a library identifier.

    If such configuration file exists, the \texttt{test-runner.sh}
    script~\ref{ref:test-execution} tries to read it and if it is a valid
    configuration, it passes all parsed information to the \texttt{scripts/lib-compile.sh}
    script. This script contains recipes for all supported libraries, as
    each library has a custom way of compilation and installation.
    If the compilation fails, the job is immediately aborted and a build log
    is printed to the resulting log to be analysed. Otherwise, the test runner continues
    as usual with execution of all relevant tests for given environment.

    This solution has a few disadvantages -- the library is compiled in each
    job, which is unnecessary, and it requires a separate branch to be created
    manually by a developer, with the custom configuration file. The first
    issue is particularly hard to solve, as the jobs does not have any shared
    space, and usually run in pararel. The second issue it not easy to solve
    without incorporating some kind of external system or watchdog. As this
    implementation is currently being discussed and tested by developers, it is possible
    it will be improved or replaced completely in the future.

\section{Test Extension Details} \label{ref:test-extension-details}
    As this thesis started with already existing tests (and its purpose was
    to extend them), following paragraphs should make clear what was already
    implemented and what is the result of this thesis.

\subsection{GnuTLS}
\subsubsection{gnutls/renegotiation-with-NSS}
    New features:
    \begin{itemize}
        \item Use certgen library for generating certificates
        \item Test 20 ciphersuites instead of only the default one
        \item Test renegotiation scenarios with client certificates
    \end{itemize}

    \noindent Overall stats: 457 additions, 32 deletions

\subsubsection{gnutls/renegotiation-with-OpenSSL}
    New features:
    \begin{itemize}
        \item Use certgen library for generating certificates
        \item Test 20 ciphersuites instead of only the default one
        \item Test renegotiation scenarios with client certificates
    \end{itemize}

    \noindent Overall stats: 399 additions, 24 deletions

\subsubsection{gnutls/resumption-with-NSS}
    New features:
    \begin{itemize}
        \item Create certificate PKI
        \item Test 20 ciphersuites instead of only the default one
        \item Test resumption scenarios with client certificates and with
            SessionTicket extension
    \end{itemize}

    \noindent Overall stats: 469 additions, 35 deletions

\subsubsection{gnutls/resumption-with-OpenSSL}
    New features:
    \begin{itemize}
        \item Use certgen library for generating certificates
        \item Test 20 ciphersuites instead of only the default one
        \item Test resumption scenarios with client certificates and with
            SessionTicket extension
    \end{itemize}

    \noindent Overall stats: 425 additions, 29 deletions

\subsubsection{gnutls/signature\_algorithms-with-OpenSSL}
\todo{finish when the test is done}

\subsubsection{gnutls/TLSv1-2-with-NSS}
    New features:
    \begin{itemize}
        \item Explicitly enable RC4 and DHE-DSS
        \item Temporarily ignore crypto-policies on Fedora
    \end{itemize}

    \noindent Overall stats: 13 additions, 6 deletions

\subsubsection{gnutls/TLSv1-2-with-OpenSSL}
    New features:
    \begin{itemize}
        \item Explicitly enable RC4 and DHE-DSS
    \end{itemize}

    \noindent Overall stats: 7 additions, 6 deletions

\subsection{NSS}
\subsubsection{nss/CC-nss-with-gnutls}
    New features:
    \begin{itemize}
        \item Explicitly enable RC4 and DHE-DSS
    \end{itemize}

    \noindent Overall stats: 10 additions, 3 deletions

\subsubsection{nss/Interoperability-with-OpenSSL}
\todo{find out what happened with the WIP version}

\subsubsection{nss/renego-and-resumption-NSS-with-OpenSSL}
    New features:
    \begin{itemize}
        \item OpenSSL-NSS - basic interoperability
        \item OpenSSL-NSS - basic interoperability with client certificates
        \item NSS-OpenSSL - fixed basic interoperability
        \item NSS-OpenSSL - fixed basic interoperability with client
            certificates
        \item NSS-OpenSSL - session renegotiation
        \item NSS-OpenSSL - session renegotiation with client certificates
        \item NSS-OpenSSL - session resumption
        \item NSS-OpenSSL - session resumption with client certificates
        \item Add missing expect scripts
    \end{itemize}

    \noindent Overall stats: 343 additions, 61 deletions

\subsection{OpenSSL}
\subsubsection{openssl/CC-openssl-with-gnutls}
    New features:
    \begin{itemize}
        \item Explicitly enable RC4 and DHE-DSS
    \end{itemize}

    \noindent Overall stats: 9 additions, 2 deletions

\section{Outstanding Issues(?)}
    \todo{FIPS} \\
    \todo{REF: https://www.nist.gov/information-technology-laboratory/fips-general-information}
    \todo{expect scripts - random hangups, unreliability, ...}


\chapter {Testing Results} \label{chap:testing_results}
    Throughout the test extension process, several bugs and issues were found
    in the tested libraries, as well as in the auxiliary utilities. These
    issues have various levels of security impact and will be described in
    detail in this chapter.

    \bigskip\noindent Described issues have following format:

    \subsubsection*{Issue ID(s) \newline [severity, affected systems] \newline Issue summary}
    Issue description

    \medskip\noindent <version>: <link to component's issue tracker>

    \bigskip\noindent Issue ID abbreviations:
    \begin{description}
        \item[CVE] Common Vulnerabilities and Exposures~\footnote{https://cve.mitre.org/}
        \item[BZ] Red Hat bug-tracking system~\footnote{https://bugzilla.redhat.com/}
        \item[MBZ] Mozilla bug-tracking system~\footnote{https://bugzilla.mozilla.org/}
    \end{description}

\section{NSS}
\subsubsection*{{\color{red} CVE-2016-9574}, BZ\#1397482, BZ\#1397410 \newline
    [Urgent, RHEL/CentOS 6, RHEL/CentOS 7] \newline
    Segfault in selfserv during session handshake when using SessionTicket
    extension and ECDHE-ECDSA ciphersuites}

    \texttt{selfserv} utility crashes during handshake when using SessionTicket
    extension for session resumption. This issue although does not occur when
    using client certificates.

    \medskip\noindent CVE: \url{https://access.redhat.com/security/cve/CVE-2016-9574}
    \newline\noindent RHEL/CentOS 6: \url{https://bugzilla.redhat.com/show_bug.cgi?id=1397482}
    \newline\noindent RHEL/CentOS 7: \url{https://bugzilla.redhat.com/show_bug.cgi?id=1397410}

\subsubsection*{BZ\#1426182, MBZ\#1320695 \newline
    [Urgent, RHEL/CentOS 7, upstream] \newline
    Support ticket based session resumption using only ECDSA certificate}

    Using SessionTicket extension along with any ECDHE-ECDSA ciphersuite
    renders \texttt{selfserv} server unusable.

    \medskip\noindent RHEL/CentOS 7: \url{https://bugzilla.redhat.com/show_bug.cgi?id=1426182}
    \newline\noindent Upstream: \url{https://bugzilla.mozilla.org/show_bug.cgi?id=1320695}

\subsubsection*{BZ\#1436114, MBZ\#1350950 \newline
    [Unspecified, RHEL/CentOS 7, upstream] \newline
    Sending of CERTIFICATE REQUEST messages does not correspond to manual}

    When \texttt{-r} or \texttt{-rr} parameter is used with \texttt{sefserv}
    utility, to request (and require) client certificate on initial handshake,
    the CERTIFICATE REQUEST message is sent on both handshakes, whereas when
    \texttt{-rrr} or \texttt{-rrrr} parameter is used, the CERTIFICATE REQUEST
    message is not sent at all. This does not correspond to the manual of
    the \texttt{selfserv} utility, which states following:

    \begin{lstlisting}
-r flag is interepreted as follows:
    1 -r  means request, not require, cert on initial handshake.
    2 -r's mean request  and require, cert on initial handshake.
    3 -r's mean request, not require, cert on second handshake.
    4 -r's mean request  and require, cert on second handshake.
    \end{lstlisting}

    \medskip\noindent RHEL/CentOS 7: \url{https://bugzilla.redhat.com/show_bug.cgi?id=1436114}
    \newline\noindent Upstream: \url{https://bugzilla.mozilla.org/show_bug.cgi?id=1350950}

\subsubsection*{BZ\#1397486, BZ\#1397472, MBZ\#1320708 \newline
    [Low, RHEL/CentOS 6, RHEL/CentOS 7, upstream] \newline
    strsclnt gets stuck during session resumption when using client certificates}

    \texttt{strsclnt} utility gets stuck during session resumption (for both
    SessionTicket and SessionID) when using client certificates and when the
    server has enabled client certificate verification.

    \medskip\noindent RHEL/CentOS 6: \url{https://bugzilla.redhat.com/show_bug.cgi?id=1397486}
    \newline\noindent RHEL/CentOS 7: \url{https://bugzilla.redhat.com/show_bug.cgi?id=1397472}
    \newline\noindent Upstream: \url{https://bugzilla.mozilla.org/show_bug.cgi?id=1320708}

\subsubsection*{BZ\#1397478, BZ\#1397365 \newline
    [Low, RHEL/CentOS 6, RHEL/CentOS 7] \newline
    NSS session resumption using session ID does not work for DHE-DSS ciphersuites}

    When NSS acts as a server, session resumption using SessionID does not work
    for ciphersuites using DHE-DSS algorithm. Even though this behavior is
    expected for the ticket based resumption, the Session ID resumption should work.

    \medskip\noindent RHEL/CentOS 6: \url{https://bugzilla.redhat.com/show_bug.cgi?id=1397478}
    \newline\noindent RHEL/CentOS 7: \url{https://bugzilla.redhat.com/show_bug.cgi?id=1397365}

\subsubsection*{BZ\#1426267 \newline
    [Unspecified, Fedora 25] \newline
    Broken Crypto Policy handling of RC4 ciphersuites}

    On F25 RC4 ciphers in NSS should be disabled by Crypto Policy, but in the
    current version it works only partially - when NSS acts as a client,
    the handshake fails, but when it acts as a server, the handshake is
    completed successfully.

    \medskip\noindent Fedora 25: \url{https://bugzilla.redhat.com/show_bug.cgi?id=1426267}

\section{GnuTLS}
\subsubsection*{BZ\#1401564 \newline
    [Unspecified, RHEL/CentOS 7] \newline
    Duplicate PK signature algorithms in gnutls-cli output}

    Output of \texttt{gnutls-cli -l} command contains duplicate public key signature
    algorithms -- namely \texttt{SIGN-RSA-SHA1} and \texttt{SIGN-RSA-MD5}.

    \medskip\noindent RHEL/CentOS 7: \url{https://bugzilla.redhat.com/show_bug.cgi?id=1401564}

\subsubsection*{BZ\#1434091, BZ\#1434420 \newline
    [Unspecified, RHEL/CentOS 7] \newline
    Session renegotiation fails with client certificates}

    GnuTLS sends a client certificate in renegotiation, even if it was not
    requested by the server, causing the handshake to fail.

    \medskip\noindent RHEL/CentOS 7: \url{https://bugzilla.redhat.com/show_bug.cgi?id=1434091}
    \newline\noindent Fedora 25: \url{https://bugzilla.redhat.com/show_bug.cgi?id=1434420}

\section{BeakerLib}
\subsubsection*{BZ\#1416014 \newline
    [High, upstream] \newline
    rlWaitForSocket --close now waits for incorrect socket}

    A patch in the latest testing version of beakerlib causes that
    \texttt{rlWaitForSocket --close} can cause a deadlock/unwanted delay,
    because of grepping an incorrect socket.

    \medskip\noindent Upstream: \url{https://bugzilla.redhat.com/show_bug.cgi?id=1416014}

\chapter {Conclusion} \label{chap:conclusion}
\todo{summarize findings, current CI state, future work (if any), ...}

% Proposed ToC
% 1. Introduction
% 2. Used Technologies
%   2.1 Secure Socket Layer/Transport Layer Security
%   ...
%   2.2 Continuous Integration
%   ... Jenkins, OS, Travis, ...
% 3. Implementation Details
%   3.1 Testing Process
%   ...
%       3.1.x Test Suite Extension
%   3.2 Continuous Integration
%   ...
% 4. Testing Results
% 5. Conclusion
