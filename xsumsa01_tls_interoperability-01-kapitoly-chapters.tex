%=========================================================================
% (c) Michal Bidlo, Bohuslav KÅ™ena, 2008

\chapter{Introduction}
    \todo{TODO !!!1}

\chapter{SSL/TLS}
    \textit{Secure Socket Layer}~(SSL) and its successor
    \textit{Transport Layer Security}~(TLS) are cryptographic protocols
    designed to provide communications security over a computer network. As
    the latest version of the SSL protocol (version~3.0~\cite{rfc6101}) was
    deprecated in June~2015~\cite{rfc7568} it will not be discussed
    further in this thesis.

    Although there are currently three TLS versions -- TLS 1.0~\cite{rfc2246},
    TLS 1.1~\cite{rfc4346} and TLS 1.2~\cite{rfc5246} -- this thesis focuses
    only on the latest two as TLS 1.0 is basically SSL 3.0 with a few
    differences. Also, there were few cryptographic problems found
    in TLS 1.0 and later resolved in TLS 1.1 (e.g. BEAST~\cite{duong2011}).

\section{Overview}\label{ref:overview}
    \todo{TLS history?}
    The primary goal of the TLS protocol is to provide privacy and data
    integrity between two communicating applications. The structure of
    the protocol comprises two layers: the TLS Record Protocol and
    the TLS Handshake Protocol.

    The TLS Record Protocol lies at the lowest level, above some reliable
    transport protocol (e.g., TCP~\footnote{Transmission Control Protocol}).
    This protocol provides security which has following properties:
    \begin{itemize}
        \item The connection is private. Symmetric cryptography is used
        for data encryption (e.g., AES~\footnote{Advanced Encryption Standard},
        Camellia, 3DES~\footnote{Triple DES (Data Encryption Standard)}, etc.).
        The keys for the symmetric encryption are generated uniquely
        for each connection
        and are based on a secret negotiated by another protocol
        (such as the TLS Handshake Protocol). The TLS Record Protocol can also
        be used without encryption.
        \item The connection is reliable. Message transport includes
        a message integrity check using a keyed
        MAC~\footnote{Message Authentication Code}. Secure hash functions
        (e.g., SHA-1~\footnote{Secure Hash Algorithm}, SHA-256, etc.) are
        used for MAC computations. The MAC is used to prevent undetected
        data loss or data modification during transmission.
    \end{itemize}

    The TLS Record Protocol is used for encapsulation of various higher-level
    protocols. One such protocol is the TLS Handshake Protocol. This protocol
    allows client authentication and negotiation of necessary properties
    of the TLS connection, like encryption algorithm or cryptographic keys,
    before the data transmission. The TLS Handshake Protocol provides
    connection security which has following properties:
    \begin{itemize}
        \item The peer's identity can be authenticated using asymmetric, or
        public key, cryptography (e.g.,
        RSA~\footnote{Rivest-Shamir-Adleman cryptosystem},
        ECDSA~\footnote{Elliptic Curve Digital Signature Algorithm}, etc.).
        This authentication is not mandatory, but it is generally required
        for at least one of the peers.
        \item The negotiation of a shared secret is secure. Obtaining of
        the shared secred is infeasible for any eavesdropper or attacker,
        who can place himself in the middle of the authenticated connection.
        \item The negotiation is reliable. The negotiation communication
        cannot be modified without being detected by the parties to the
        communication.~\cite{rfc5246}
    \end{itemize}

    In addition to the properties above, a carefully configured TLS connection
    can provide another important privacy-related property: forward secrecy.
    This property ensures, that any future disclosure or leakage of encryption
    keys cannot be used to decrypt any TLS communnications recorded or
    eavesdropped in the past.

    TLS supports various combinations of algorithms for key exchange, data
    encryption and message integrity authentication, which is an important fact
    for this thesis and can cause severe issues when these combinations
    are configured or implemented improperly. Along with these combinations,
    TLS supports many extensions further extending its capabilities and possibilites,
    which will be described further in this thesis.

\section{TLS Protocols}
    As mentioned above, the TLS protocol consists of four protocols --
    the TLS Record Protocol, the TLS Handshake Protocol, the TLS Changer Cipher
    Spec Protocol, the TLS Alert Protocol and the TLS Application Data Protocol.
    In this section we will overview and discuss these protocols in more detail.

\subsection{TLS Record Protocol}
    In section \ref{ref:overview} we briefly described the main function of the
    TLS Record Protocol, which is encapsulation of protocol data from higher
    layers. This includes fragmentation, optional compression, MAC application,
    encryption and transmission of the data. On the receiving side the data is
    decrypted, verified, decompressed, reassembled and then delivered to the
    higher layers.

    Through the data processing, following TLS data structures are used --
    \texttt{TLSPlaintext}, \texttt{TLSCompressed} and \texttt{TLSCiphertext}.
    At the end a TLS record is formed by appending an TLS record header to
    the \texttt{TLSCiphertext} structure.

    \todo{Describe fragmentation, compression and encryption?}
\subsection{TLS Handshake Protocol} \label{ref:tls_handshake_protocol}
    The TLS Handshake Protocol is the core protocol of TLS which operates on
    top of the TLS Record Protocol. Its goal is the authentication of communnicating
    peers and negotiaton of security parameters necessary for establishment or
    resumption of secure sessions.

    \todo{current/pending write/read state}

    \noindent The session establishment consists of following steps:
    \begin{itemize}
        \item Protocol version negotiation
        \item Cipher suite negotiation
        \item Server authentication and (optional) client authentication using
              digital certificates
        \item Exchange of session key information
    \end{itemize}

    \noindent The actual session establishment using the TLS Handshake Protocol
    proceeds as follows (see~Figure~\ref{fig:full_tls_handshake}):
    \begin{enumerate}
        \item The client sends a \texttt{ClientHello} message to the server, that
              includes the TLS version a list of cipher suites supported by the
              client (in the client's order of preference) and the client's
              random value, which is used in subsequent computations.
        \item The server responds with a \texttt{ServerHello} message, including
              the protocol version, the cipher suite chosen by the server, the session ID,
              and the server's random value.
        \item If the server is to be authenticated, it sends its certificate in
              a \texttt{Certificate} message.
        \item A \texttt{ServerKeyExchange} message may be sent if the client
              needs some additional information for the key exchange.
        \item If a client authentication is required, the server sends a
              \texttt{CertificateRequest}.
        \item Finally, the server sends a \texttt{ServerHelloDone} message, to
              indicate that the hello-message phase of the handshake is complete.
        \item If the server has sent the \texttt{CertificateRequest} message, the
              client must send the \texttt{Certificate} message containing its
              certificate.
        \item The client sends a \texttt{ClientKeyExchange} message. Its content
              depends on the chosen key exchange algorithm.
        \item If the client has sent its certificate to the server, it must also
              send a digitally-signed \texttt{CertificateVerify} message, which
              explicitly verifies posession of the private key belonging to the
              client's certificate.
        \item The client sends a \texttt{ChangeCipherSpec} message to the server,
              using the TLS Change Cipher Spec Protocol (see
              section \ref{ref:change_cipher_spec}) and copies its pending write state
              into the current write state.
        \item The client sends a \texttt{Finished} message to the server under
              the new write state (with the new algorithms, keys, and secrets).
        \item In response, the server sends its own \texttt{ChangeCipherSpec}
              message, copies its pending write state into the current write
              state and send the \texttt{Finished} message under the new cipher
              spec.
    \end{enumerate}

    \begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \tikzstyle{block} = [draw, rectangle, minimum width=5.5em, minimum height=2.2em, node distance=15em]
        \node[block] (Client) {Client};
        \node[block,right=of Client] (Server) {Server};
        \node[below of=Server, node distance=28em] (ServerGround) {};
        \node[below of=Client, node distance=28em] (ClientGround) {};

        \draw (Client) -- (ClientGround);
        \draw (Server) -- (ServerGround);

        \draw[->] ($(Client)!0.15!(ClientGround)$) -- node[above]{\texttt{ClientHello}} ($(Server)!0.15!(ServerGround)$);

        \draw[<-] ($(Client)!0.25!(ClientGround)$) -- node[above]{\texttt{ServerHello}} ($(Server)!0.25!(ServerGround)$);
        \draw[<-] ($(Client)!0.30!(ClientGround)$) -- node[above]{\texttt{Certificate*}} ($(Server)!0.30!(ServerGround)$);
        \draw[<-] ($(Client)!0.35!(ClientGround)$) -- node[above]{\texttt{ServerKeyExchange*}} ($(Server)!0.35!(ServerGround)$);
        \draw[<-] ($(Client)!0.40!(ClientGround)$) -- node[above]{\texttt{CertificateRequest*}} ($(Server)!0.40!(ServerGround)$);
        \draw[<-] ($(Client)!0.45!(ClientGround)$) -- node[above]{\texttt{ServerHelloDone}} ($(Server)!0.45!(ServerGround)$);

        \draw[->] ($(Client)!0.55!(ClientGround)$) -- node[above]{\texttt{Certificate*}} ($(Server)!0.55!(ServerGround)$);
        \draw[->] ($(Client)!0.60!(ClientGround)$) -- node[above]{\texttt{ClientKeyExchange}} ($(Server)!0.60!(ServerGround)$);
        \draw[->] ($(Client)!0.65!(ClientGround)$) -- node[above]{\texttt{CertificateVerify*}} ($(Server)!0.65!(ServerGround)$);
        \draw[->] ($(Client)!0.70!(ClientGround)$) -- node[above]{\texttt{[ChangeCipherSpec]}} ($(Server)!0.70!(ServerGround)$);
        \draw[->] ($(Client)!0.75!(ClientGround)$) -- node[above]{\texttt{Finished}} ($(Server)!0.75!(ServerGround)$);

        \draw[<-] ($(Client)!0.85!(ClientGround)$) -- node[above]{\texttt{[ChangeCipherSpec]}} ($(Server)!0.85!(ServerGround)$);
        \draw[<-] ($(Client)!0.90!(ClientGround)$) -- node[above]{\texttt{Finished}} ($(Server)!0.90!(ServerGround)$);

        \draw[<->, thick] ($(Client)!0.98!(ClientGround)$) -- node[above]{\texttt{Application Data}} ($(Server)!0.98!(ServerGround)$);
    \end{tikzpicture}
    \caption{Full TLS handshake} \label{fig:full_tls_handshake}
    \end{figure}

    Note: * marks messages which are sent only under specific conditions. \\

    At this point the TLS handshake is complete, and the peers may begin to
    exchange application layer data.

    When the client and the server decide to resume a previous session or duplicate
    an existing one, the handshake can be simplified considerably
    (see Figure~\ref{fig:simplied_tls_handshake}). The client
    sends a \texttt{ClientHello} message including the ID of the session to be
    resumed. The server then checks its session cache for a match. If a match
    is found, and the server is willing to re-establish the connection under
    the specified session state, it sends a \texttt{ServerHello} message with
    the same Session ID value. The client and the server can then directly move
    to the \texttt{ChangeCipherSpec} message followed by the \texttt{Finished}
    message. If a Session ID match is not found in the session cache, the
    server generates a new session ID and the peers perform a full TLS handshake.

    \begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \tikzstyle{block} = [draw, rectangle, minimum width=5.5em, minimum height=2.2em, node distance=15em]
        \node[block] (Client) {Client};
        \node[block,right=of Client] (Server) {Server};
        \node[below of=Server, node distance=14em] (ServerGround) {};
        \node[below of=Client, node distance=14em] (ClientGround) {};

        \draw (Client) -- (ClientGround);
        \draw (Server) -- (ServerGround);

        \draw[->] ($(Client)!0.20!(ClientGround)$) -- node[above]{\texttt{ClientHello}} ($(Server)!0.20!(ServerGround)$);

        \draw[<-] ($(Client)!0.35!(ClientGround)$) -- node[above]{\texttt{ServerHello}} ($(Server)!0.35!(ServerGround)$);
        \draw[<-] ($(Client)!0.45!(ClientGround)$) -- node[above]{\texttt{[ChangeCipherSpec]}} ($(Server)!0.45!(ServerGround)$);
        \draw[<-] ($(Client)!0.55!(ClientGround)$) -- node[above]{\texttt{Finished}} ($(Server)!0.55!(ServerGround)$);

        \draw[->] ($(Client)!0.70!(ClientGround)$) -- node[above]{\texttt{[ChangeCipherSpec]}} ($(Server)!0.70!(ServerGround)$);
        \draw[->] ($(Client)!0.80!(ClientGround)$) -- node[above]{\texttt{Finished}} ($(Server)!0.80!(ServerGround)$);

        \draw[<->, thick] ($(Client)!0.98!(ClientGround)$) -- node[above]{\texttt{Application Data}} ($(Server)!0.98!(ServerGround)$);
    \end{tikzpicture}
    \caption{Simplied TLS handshake} \label{fig:simplied_tls_handshake}
    \end{figure}


    Let's have a closer look at the various messsages that are exchanged during
    the TLS handshake:

\subsubsection{\texttt{HelloRequest}}
    This message may be sent by the server at any time and tells the client
    to begin a new session negotiation. Client should respond to this
    message with a \texttt{ClientHello}. This message is not often used, but
    it can be useful in some cases, e.g. forcing a session renegotiation for
    a TLS sessions which are active for a longer period of time.

\subsubsection{\texttt{ClientHello}} \label{ref:client_hello}
    The \texttt{ClientHello} message is usually the first message in the TLS
    handshake, sent by the client, which initiates the session negotiation.
    The message itself contains the latest TLS version supported by the client,
    the client's random value, a session ID (which can be empty, if the client
    wishes to negotiate a new session), a list of supported cipher suites,
    a list of compression methods and optional extensions.

\subsubsection{\texttt{ServerHello}}
    The \texttt{ServerHello} is the server's response to the client's
    \texttt{ClientHello} message. The structure of this message is quite similar
    to the \texttt{ClientHello} -- instead of the lists of cipher suites and
    compression methods, the server specifies a single cipher suite and a single
    compression method. These values are chosen from the client's \texttt{ClientHello}
    message and will be used for the session. The complete message contains
    the TLS version chosen by the server, the server's random value, the length
    of the session ID and the session ID, the cipher suite, the compression
    method and the optional extensions.

\subsubsection{\texttt{Certificate}}
    If the agreed-upon key exchange method uses certificates for authentication,
    the server sends a \texttt{Certificate} message containing a
    certificate chain. This certificate chain can be then used by the client,
    to verify the server's identity. The same message is used when a client
    authentication is required (as a response to a \texttt{CertificateRequest}
    message, see below). All exchanged certificates are of X.509 v3
    type~\cite{rfc5280}, if not stated otherwise during the negotiaton.

\subsubsection{\texttt{ServerKeyExchange}}
    In some cases, the \texttt{Certificate} message does not contain enough data to
    allow the client to exchange a premaster secret. In this situation, the
    server sends a \texttt{ServerKeyExchange} message with necessary cryptographic
    information, which allows such exchange and allows the client to complete
    a key exchange.

    When RSA (or Diffie-Hellman with fixed parameters) is used, the client can retrieve
    the public key (or the server's Diffie-Hellman parameters) from the server certificate.
    In these cases the \texttt{Certificate} message is enough to complete
    a key exchange. But, for example, in case of ephemeral Diffie-Hellman, the client
    needs some additional information --- Diffie-Hellman parameters --- which
    must be delivered in a \texttt{ServerKeyExchange} message.

\subsubsection{\texttt{CertificateRequest}}
    When the server wants to authenticate the client, it sends
    a \texttt{CertificateRequest} message to the client. This message tells
    the client, which certificates are accepted by the server, and also asks
    the client to send its certificate to the server. Only a non-anonymous
    server can send a \texttt{CertificateRequest} -- that means a server, which
    authenticates itself using the \texttt{Certificate} message.

\subsubsection{\texttt{ServerHelloDone}}
    This message is sent by the server and indicates the end of the section
    of messages initiated by the \texttt{ServerHello} message. After sending
    this message, the server will wait for a client response.

\subsubsection{\texttt{ClientKeyExchange}}
    The \texttt{ClientKeyExchange} message is sent by the client and it provides
    the server with the client-side keying material, which is used to generate
    the premaster secret.

\subsubsection{\texttt{CertificateVerify}}
    If the client provided a certificate that has signing capability, then it
    must prove that it holds the corresponding private key for that certificate.
    In this case, the client sends a digitally signed \texttt{CertificateVerify}
    message to the server. This allows the server to verify the client certificate
    using the client's public key and authenticate the client.

\subsubsection{\texttt{Finished}}
    The \texttt{Finished} message is always sent immediately after a
    \texttt{ChangeCipherSpec} message~\ref{ref:change_cipher_spec} to verify
    that the key exchange and authentication processes were successful.
    As the message follows the \texttt{ChangeCipherSpec} message, it is the
    first message protected by the newly negotiated algorithms and keys.

\subsection{TLS Change Cipher Spec Protocol} \label{ref:change_cipher_spec}
    The TLS Change Cipher Spec Protocol is used to signal transitions in
    ciphering strategies. The protocol itself consists of a single compressed
    and encrypted message -- \texttt{ChangeCipherSpec}. The encryption and
    compression method corresponds to the current (not the pending) cipher
    spec.

    After receiving this message, the receiver instructs its record layer
    to immediately copy the read pending state into the read current state.
    Similarly, immediately after sending this messsage, the sender instructs
    its record layer to copy the write pending state into the write current
    state. All subsequent messages sent by the sender are then protected under
    the newly negotiated cipher spec.

\subsection{TLS Alert Protocol}
    To exchange alert messages between peers, like warnings and errors, the
    TLS Alert Protocol is used. Each alert message has its severity (warning,
    fatal) and a description of the alert. All messages with an alert level
    of fatal result in the immediate termination of the connection.

    The alert's description field contains an identificator of the alert.
    These descriptions can be split into two categories -- closure alerts
    and error alerts. The former one contains only one alert --
    \texttt{close\_notify}. This message can be send by either party and
    notifies the recipient that the
    sender will not send any more messages. Any data received after this message
    must be ignored. The knowledge of the fact, that the connection is ending,
    is crucial to avoid truncation attacks.
    The second category contains a number of error alerts used for various
    purposed during the TLS session. All TLS alert messages are summarized
    in Table~\ref{tab:tls-alerts}.

\subsection{TLS Application Data Protocol}
    The TLS Application Data Protocol takes the arbitrary data from the application
    layer and feeds it into the TLS Record Protocol for fragmentation, compression
    and encryption. The resulting TLS records are then sent to the recipient.

\section{Cipher Spec and Cipher Suite}
    In previous sections we mentioned terms \textit{cipher spec} and
    \textit{ciper suite}. Let's have a closer look at their meanings.

    A \textit{cipher spec} refers to a pair of algorithms that are used
    cryptographically protect data. Such pair consists of a message
    authentication algorithm (\textit{MAC}) and a data encryption algorithm. If we
    add a key exchange algorithm to a cipher spec, we get a \textit{cipher suite}.

    For example, \textit{TLS\_DHE\_RSA\_AES\_256\_CBC\_SHA1} refers to a TLS
    cipher suite which uses ephemeral Diffie-Hellman with RSA for a key
    exchange, 256-bit AES in CBC~\footnote{Cipher Block Chaining} mode for
    encryption, and SHA-1 for message authentication.
    \todo{List of cipher suites?}

\section{TLS Extensions}
    As mentioned in section~\ref{ref:tls_handshake_protocol}, the \texttt{ClientHello}
    and \texttt{ServerHello} messages contain an optional field for extensions.
    These extensions can be used to add functionality to TLS.

    When a client wants to use an extension
    it sends its name in the \texttt{ClientHello} message. If the
    extension is supported by the server, it will be included in the responding
    \texttt{ServerHello} message. However, if the \texttt{ServerHello} message
    contains an extension, which was not sent by the client, the connection
    must be aborted with an \texttt{unsupported\_extension} fatal
    alert~(\ref{tab:tls-alerts}).~\cite{rfc3546}~\cite{rfc4366}

    Describing all currently implemented extensions~\cite{rfc6066} is
    way beyond scope of this thesis.
    Thus, in the following paragraphs, we will discuss only those extensions,
    which are currently tested by the implementation part of this thesis.
    Nevertheless, support for other extensions is highly probable in
    the near future.

\subsection{Session Tickets}
    If a client wanted to resume an existing session, it would have to
    send a session ID in its \texttt{ClientHello} message (field \texttt{session\_id})
    and the server would have to check its cache for a match (see
    section~\ref{ref:tls_handshake_protocol}). This may cause problems on systems
    with a large amount of requests from different users or on systems with
    little memory. For such cases there is a \texttt{SessionTicket} TLS extension which uses
    client-side caching.~\cite{rfc5077}

    In the initial handshake, where the client does not possess a ticket for an existing
    session, it includes an empty \texttt{SessionTicket} TLS extension in
    its \texttt{ClientHello} message. The server responds with an empty
    \texttt{SessionTicket} extension to indicate that it will send a new session
    ticket using the \texttt{NewSessionTicket} message. This ticket contains
    the current session state (such as ciphersuite and master secret) and is
    cryptographically protected by a key, which is known only to the server.

    When the client wishes to resume the session, it includes the cached ticket
    in the \texttt{SessionTicket} extension of its \texttt{ClientHello} message.
    The server then decrypts and verifies the contents of the ticket and resumes
    the session according to the decrypted parameters. If the server cannot
    or does not want to use the state from the ticket, then it can initiate
    a full handshake with the client.

\subsection{Signature Algorithms}
    TLS 1.2 defines (\cite{rfc5246}, section 7.4.1.4.1) an extension
    \texttt{supported\_signature\_algorithms}, which allows a client to tell
    the server which hash and signature algorithm combinations it supports.
    Even though internally the supported algorithms are split into two lists
    (none, MD5, SHA-1, SHA-224, SHA-256, SHA-384 and SHA-512 for hash algorithms
    and anonymous, RSA, DSA and ECSDA for signature algorithms), the algorithms
    sent in the extension are always listed in pairs, as not all combinations
    may be accepted by an implementation.

    The peers exchange this information through the \texttt{ClientHello} and
    \texttt{ServerHello} messages including the \texttt{supported\_signature\_algorithms}
    extension. The client sends a list of supported algorithms and the server
    responds with its choicei, that is going to be used for subsequent signature
    generation and verification.


\chapter{Continuous Integration}
\todo{(overview, jenkins, travis, semaphore, beaker, openstack, ...)}
\todo{current state - github, travis, docker, beakerlib, ...}

\chapter {SSL/TLS Testing}
    Before the testing itself, we have to know what should be tested, how it
    should be tested and where, or to be more precise, which environments it
    should be tested in.

\section{Tested Libraries}
    To prevent each project implementing the SSL/TLS on its own and introducing
    (in many situations) dangerous issues, several libraries were created and
    can be used by any project, which needs a SSL/TLS support. The most
    popular ones are OpenSSL~\footnote{https://www.openssl.org/},
    NSS~\footnote{https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS}
    and GnuTLS~\footnote{https://www.gnutls.org/}. Although, there are other
    SSL/TLS libraries (e.g. LibreSSL~\footnote{https://www.libressl.org/} or
    BoringSSL~\footnote{https://boringssl.googlesource.com/boringssl/}),
    this thesis aims only on these three. However, a future
    expansion to support other libraries is not impossible.

    Even though these libraries are
    separate projects, an user must be able to communicate with every client,
    which supports the particular protocol and ciphersute, no matter which
    implementation they use. Testing of this functionality --- \textit{interoperability} ---
    is the main goal of this thesis.

    For the testing itself we need at least two applications - a client and a server.
    One option would be writing these applications using the public
    API~\footnote{Application Programming Interface} of each library,
    which is not error prone and would require a maintenance of such applications.
    Thankfully, each of the tested libraries provides a set of utilities,
    among which we can found a simple client and server application with
    dozens of settings and options. These applications are then used in
    various scenarios to ensure, that given valid combination of settings works
    for both client and a server using different libraries.

\subsection{OpenSSL}
    OpenSSL is an open source library maintained by The OpenSSL Project,
    which provides a toolkit for TLS and SSL
    protocols, along with other general-purpose cryptographic functions.

    This library provides a single powerful utility called \textit{openssl}. This
    utility has dozens of subcommands with various SSL/TLS related functionality,
    where the most important ones are:
    \begin{description}
        \item [ciphers] information about supported ciphersuites
        \item [dsa, rsa, ec] DSA/RSA/EC key management
        \item [s\_client] a simple SSL/TLS client
        \item [s\_server] a simple SSL/TLS server
        \item [x509] X.509 certificate data management
    \end{description}

    Thanks to its functionality-rich interface, OpenSSL is used for certificate
    generation and management for all libraries in the testing process.

\subsection{NSS}
    Network Security Services~(NSS) is a set of open source libraries providing
    support for SSL and TLS protocols,
    S/MIME~\footnote{Secure/Multipurpose Internet Mail Extensions}
    and other optional features, like
    server-side TLS/SSL acceleration or client-side hardware smart cards support.

    Compared to OpenSSL, which has a single utility for everything, NSS does
    the exact opposite - each feature or tool has its own utility. For our
    testing purposes, we will need the following ones:
    \begin{description}
        \item [certutil] certificate and key management for NSS databases
        \item [listsuites] information about supported ciphersuites
        \item [selfserv] a simple SSL/TLS server
        \item [strsclnt] a simple SSL/TLS client for performance testing
        \item [tstclnt] a simple SSL/TLS client
    \end{description}

    This library differs from the other two in the way how it handles
    server and client certificates. These certificates cannot be passed
    directly as arguments to the utility, but must be imported to a NSS
    database which is then passed as an argument to the utility.

\subsection{GnuTLS}
    GnuTLS is a secure communications library which implements SSL, TLS and
    DTLS~\footnote{Datagram Transport Layer Security} protocols.

    Like the the libraries above, GnuTLS includes several utilities for library
    testing - GnuTLS client \textit{gnutls-cli} and GnuTLS server
    \textit{gnutls-serv}. Both utilities support a parameter \textbf{-l},
    which lists all necessary information about supported ciphersuites.

\section{Tested Environments}
    For the purposes of this thesis, an environment consists of an operating
    system (e.g.
    CentOS~\footnote{https://www.centos.org/},
    Fedora~\footnote{https://getfedora.org/}) and its version
    (e.g. 7, 25). Each of these environments must be tested separately, as
    it contains a different set of library versions and policies, which
    affect the SSL/TLS communication.

    This thesis covers SSL/TLS libraries on CentOS and Fedora, as the tests used
    and extended by this thesis were originaly created for
    RHEL~\footnote{Red Hat Enterprise Linux -
    https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux}.


    \todo{beakerlib, testplan(!), test format, relevancy, tested systems, tested libraries,
    what's not covered and why, ...}

\chapter {Testing Results}
\todo{filed bugs/CVEs, split upstream and downstream}

\chapter {Conclusion}
\todo{summarise findings, current CI state, future work (if any), ...}
